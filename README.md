MultiThreading

Introduction

- Ways to define a thread 
  
1. By extending 
2. By implementing runnable interface

- Getting and setting name of thread
- Thread priorities
- Methods to prevent thread execution
1. yield()
2. join()
3. sleep()
- Synchronisation
- InterThread Communication
- DeadLock
- Deamon Threads
- Multithreading Enhancements

============================================================================================

Two types of multitasking

1. Process based multitasking 
2. Thread Based multitasking

Process based Multitasking - Executing several tasks simultaneously where each task is independent of each other. Process based multitasking happens at OS level.
Thread based Multitasking - Executing several tasks simultaneously where each task is separate independent part of same program.
 
The main advantage of multithreading is to decrease the response time by increasing the performance.
Every thread is a flow of execution and for each thread there will be a separate job to execute.

Thread Scheduler - It is part of JVM and if there are multiple threads then in which order threads will be executed will be decided by thread scheduler.

Difference between start() and run()

start() - separate thread will e created to execute our class 
run() - it will get executed as a normal class.

- Overloading of run method is possible but when we call start method it invokes run method without arguments and the other overloaded method should be called explicitly.
- If we do not override run method, the run method of thread class will be executed which is empty.
- If you override start method, then new thread wonâ€™t be created. 
- It is not recommended to override start method. Otherwise do not go for multithreading concept.
- If we try to restart the same thread again, we will get IllegalThreadStateException.
- In comparing to both ways, implements runnable method is recommended.

Thread Life Cycle

- New/born -> Ready -> Running -> Dead

============================================================================================

Thread Priorities

- Values range of thread priorities (1 to 10)
- 1 is max priority and 10 is min priority, 5 is normal priority
- Every thread has some priority. It maybe default priority generated by JVM or customised priority.
- Some constants Thread.MIN_PRIORITY, Thread.NORM_PRIORITY, Thread.MAX_PRIORITY.
- Thread Scheduler will use priorities will allocating processor.
- Default priority for main thread is 5 and for remaining threads, the priority will get from parent thread.
- 
- 


============================================================================================

- We can prevent a thread execution by using three methods yield(), join(), sleep().

Yield()

- yield() method causes to pause current executing thread to give the chance for waiting threads of same priority.
- If there is no waiting thread or all waiting threads have low priority, then same thread can continue its execution.
- If multiple threads are waiting with same priority, we can not expect which thread will get chance, it depends on thread scheduler/


Join()

- If thread wants to wait until the completion of another thread, then we need to use join method.
- Public final void join(), public final void join(long ms)
- Every join method throws interrupted exception.
- 






















